# Redis

基于内存的单进程单线程模型的KV数据库，官方提供的数据是10w+的QPS

## 为什么使用*Redis*?

1. 速度快
速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件
> 单线程仅仅是说在网络请求这一模块上用一个线程处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理

2. 丰富的数据类型
丰富的数据类型，Redis有8种数据类型，当然常用的主要是 String、Hash、List、Set、 SortSet 这5种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过 lua 脚本自己创建新的命令（具备原子性）

3. 功能丰富
Redis还提供了像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。

4. 服务器简单
Redis的代码开源在GitHub，代码非常简单优雅；它的编译安装也是非常的简单，没有任何的系统依赖

5. 客户端语言多
有非常活跃的社区，各种客户端的语言支持也是非常完善

6. 支持持久化
RDB和AOF

7. 主从复制，高可用/分布式
## Redis的优点与缺点

## Redis的数据类型、底层实现以及各种数据类型的使用场景

### 数据类型

#### 字符串String  

特点：单一数值，可以设置过期时间。

应用：验证码、缓存(序列化和反序列化)、PV(Page View)

#### 列表List

特点：双向列表，类似于栈的功能

应用：最新列表、关注列表

#### 集合Set

特点：无序，不能重复，可以求**交集、并集、差集**

应用：点赞点踩、已读、抽奖、共同好友

#### 有序集合Sorted Set

特点：优先队列

应用：排行榜，排序的地方。取特定区域的值

#### 散列表Hash

特点：对象属性

应用：不定长属性数

### 底层实现
### 数据结构
#### 字典
~~~c
//哈希表
typedef struct dictht{
    //哈希表数组
	dictEntry **table;
    //哈希表大小
	unsigned long size;
    //哈希表大小掩码
	unsigned long sizemark;
    //已有节点的数量
	unsigned long used;
}
//哈希节点
typedef struct dictEntry{
	//键
	void *key;
	//值
	union{
		void *val;
		uint64_tu64;
		int64_ts64;
	}v;
	//指向下一个哈希表节点
	struct dictEntry *next;	
}dictEntry;
//字典
typedef struct dict{
	//类型特定函数
	dictType *type;
	//私有数据
	void *privdata;
	//哈希表
	dictht ht[2];
	//rehash索引
	int rehashidx;//默认为-1
}
~~~
## Redis是单线程吗？单线程的Redis为啥这么快？

### Redis为什么是单线程的？

需要学习线程进程，linux的相关知识点总结

### Redis为什么这么快？
1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4. 使用多路I/O复用模型，非阻塞IO
redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。

5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
~~~
以上几点都比较好理解，下边我们针对多路I/O复用模型进行简单的探讨：
多路 I/O 复用模型
多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。
采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。
~~~

## Redis持久化的方式

Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。

### RDB持久化
将某个时间点的所有数据都存放到硬盘上。

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。

如果系统发生故障，将会丢失最后一次创建快照之后的数据。

如果数据量很大，保存快照的时间会很长。
### AOF持久化

将写命令添加到 AOF 文件（Append Only File）的末尾。

使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：

|   选项   |         同步频率         |
| :------: | :----------------------: |
|  always  |     每个写命令都同步     |
| everysec |       每秒同步一次       |
|    no    | 让操作系统来决定何时同步 |

- always 选项会严重减低服务器的性能；
- everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
- no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。

随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

## 谈谈Redis的过期策略以及内存淘汰机制

过期策略：定时删除、定期删除、惰性删除

内存淘汰机制：

## 如何解决Redis和和数据库双写一致性的问题？



## 如何应对缓存穿透与缓存雪崩的问题？



## 如何解决Redis的并发竞争Key问题


